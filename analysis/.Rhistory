hoop_size="avg",
slabhard=slabhard,
slab50=slab50,
slabeasy=slabeasy,
plus1=plus1,
plus2=plus2,
minus1=minus1))
}
rm(a, i, minus1, plus1, plus2, slab50, slabeasy, slabhard)
# Save this to be used in next script
save(slabs_to_test, file = "temp/slabs_to_test")
#### Set up the distances for part 2 ####
# this is how it should be
# Block 1: easy, m, m+ 2
# Block 2: m-1, m+1, 10
# setup columns to keep
b1_keeps <- c("participant", "slabeasy", "slab50", "plus2")
b2_keeps <- c("participant", "minus1", "plus1", "slabhard")
# keep only average dist data
Block_1 <- slabs_to_test[slabs_to_test$hoop_size == "avg",]
Block_2 <- slabs_to_test[slabs_to_test$hoop_size == "avg",]
# keep only needed columns
Block_1 <- Block_1[b1_keeps]
Block_2 <- Block_2[b2_keeps]
# tidy
rm(b1_keeps, b2_keeps)
# redo names for students
colnames(Block_1) <- c("participant", "easy", "m", "m+2")
colnames(Block_2) <- c("participant", "m-1", "m+1", "hard")
#### For part 2 measures: random directions ####
# creat empty dataframe
throw_direction <- data.frame(participant = character(),
block = numeric(),
direction = numeric())
# Loop to give every trial per participant a random direction
for(i in unique(beanbagdat$participant)){
for(z in 1:2)
for(x in 1:45){
N_S <- sample(1:2, 1)
throw_direction <- rbind(throw_direction,
data.frame(participant = i,
block = z,
direction = N_S))
}
}
# tidy
rm(i, N_S, x, z)
# add appropriate labels
throw_direction$direction <- as.factor(throw_direction$direction)
throw_direction$directionNS[throw_direction$direction == "1"] <- "North"
throw_direction$directionNS[throw_direction$direction == "2"] <- "South"
rm(list = ls()
)
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
#### Load in the libraries ####
library(tidyverse)
library(reshape)
#### Created functions ####
# normalising distnace function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
dat$colour[dat$colour == "y"] <- "Y"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### this doesn't work just now... have a look again ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]*-1
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
#### normalising distance data ####
# this means we need to make all large hoops negative and standing towards these negative values too
# Also, make small hoops positive, and the standing positions closer to small hoops
# Can do this based on position data; probably separate it out...
norm_dat <- dat
# can probably loop through it?
for(i in levels(norm_dat$participant)){
for(z in rownames(norm_dat[norm_dat$large_pos > 0 & norm_dat$participant == i,])){
q <- as.numeric(z)
norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in 1:30)
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=1:30), type='response')>0.5))
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = slab))
}
}
# tidy
rm(ss, m, a, i, p, x, slab)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat2 <- merge(switch_slab_both, norm_dat)
#### bug: removes one of the participants ####
# Check the above to find source
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
rm(list = ls())
dev.off()
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
#### Load in the libraries ####
library(tidyverse)
library(reshape)
#### Created functions ####
# normalising distnace function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
dat$colour[dat$colour == "y"] <- "Y"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### this doesn't work just now... have a look again ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]*-1
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
#### normalising distance data ####
# this means we need to make all large hoops negative and standing towards these negative values too
# Also, make small hoops positive, and the standing positions closer to small hoops
# Can do this based on position data; probably separate it out...
norm_dat <- dat
# can probably loop through it?
for(i in levels(norm_dat$participant)){
for(z in rownames(norm_dat[norm_dat$large_pos > 0 & norm_dat$participant == i,])){
q <- as.numeric(z)
norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in 1:30)
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=1:30), type='response')>0.5))
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = slab))
}
}
# tidy
rm(ss, m, a, i, p, x, slab)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat <- merge(switch_slab_both, norm_dat)
#### bug: removes one of the participants ####
# Check the above to find source
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
#### get even acc stand dist ####
# get small distances first
temp_small <- melt(slabs_to_test[slabs_to_test$hoop_size == "small",],
id = c("participant", "hoop_size"))
temp_small <- temp_small[,c("participant",
"value")]
colnames(temp_small) <- c("participant",
"small_hoop_dist")
# now get avg dists
temp_avg <- melt(slabs_to_test[slabs_to_test$hoop_size == "avg",],
id = c("participant",
"hoop_size"))
temp_avg <- temp_avg[,c("participant",
"value")]
colnames(temp_avg) <- c("participant",
"avg_hoop_dist")
# merge data sets
temp_avg_small <- cbind(temp_avg, temp_small)
temp_avg_small <- temp_avg_small[,c("participant",
"avg_hoop_dist",
"small_hoop_dist")]
colnames(temp_avg_small) <- c("participant",
"hoop_pos",
"small_hoop_dist")
# get the amount of shift towards the small hoop
temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
#### get standing position for equal accuracy ####
norm_dat$equacc <- norm_dist(norm_dat$shift, norm_dat$hoop_pos)
#### add in opt standing position ####
norm_dat$optpos <- norm_dat$equacc
norm_dat$optpos[norm_dat$hoop_pos > norm_dat$switchSlab] <- 1
#### make plot of opt swithing poing by standing position ####
# still need to calculate their opt standing positions
plt <- ggplot(norm_dat, aes(hoop_pos, norm_dist))
plt <- plt + geom_point(alpha = 0.1)
plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
#plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Distance (slabs)", limits= c(0, 21))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~participant)
plr
plt
rm(list = ls())
setwd("F:/Uni/Github/TargetAbsentStoppingRules/analysis")
load("scratch/processed_data_nar_TA.rda")
df <- as.data.frame(df_TA)
rm(df_TA)
load("scratch/models/m_ta_only_temp_4")
post <- extract.samples(m_ta_only_temp_4)
link(m_ta_only_temp_4)
dev.off()
View(post)
mu.a_bl <- post$a
mu.a_ra <- post$a + post$b_isra
mu.a_si <- post$a + post$b_issi
# get slopes
mu.b_bl <- post$b_theta
mu.b_ra <- post$b_theta + post$b_ra_theta
mu.b_si <- post$b_theta + post$b_si_theta
precis(mu.a_bl, mu.a_ra, mu.a_si, mu.b_bl, mu.b_ra, mu.b_si)
precis(data.frame(mu.a_bl, mu.a_ra, mu.a_si, mu.b_bl, mu.b_ra, mu.b_si))
post$a_p[,1]
post$a_p[1,]
post$a
length(unique(df$participant))
mu.a_p_bl <- post$a + post$a_p
mu.a_p_bl <- post$a + post$a_p[,1]
rm(mu.a_p_bl)
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,1]
}
mu.a_p_bl <- 0
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,1]
}
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,1]
}
View(post)
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,i]
}
class(mu.a_bl)
class(post$a_p)
post$a_p[1]
post$a_p[1,]
post$a_p[,1]
mu.a_p_bl <- matrix(, nrow = 50, ncol = 3000)
View(mu.a_p_bl)
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,i]
}
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[,i]
}
mu.a_p_bl[i]
mu.a_p_bl[,i]
for(i in levels(unique(df$participant))){
mu.a_p_bl[,i] <- post$a + post$a_p[,i]
}
mu.a_p_bl[,i]
mu.a_p_bl[i,]
rm(list = ls())
# load in data
load("scratch/processed_data_nar_TA.rda")
# turn tibble into data.frame for map
df <- as.data.frame(df_TA)
# tidy
rm(df_TA)
# load in model
load("scratch/models/m_ta_only_temp_4")
# sample posterior
post <- extract.samples(m_ta_only_temp_4)
# how do we account for change with participant?
# probably need to make something that produces a_p and b_theta_p
# then get the slopes and intercepts based on that?
# This is just the fixed stuff for the moment
# get intercepts
mu.a_bl <- post$a
mu.a_ra <- post$a + post$b_isra
mu.a_si <- post$a + post$b_issi
# get slopes
mu.b_bl <- post$b_theta
mu.b_ra <- post$b_theta + post$b_ra_theta
mu.b_si <- post$b_theta + post$b_si_theta
df[1]
df[3]
mu.a_p_bl <- matrix(nrow = 3000, ncol = 50)
# random effects of participant
for(i in levels(unique(df$participant))){
mu.a_p_bl[,i] <- post$a + post$a_p[,i]
}
# random effects of participant
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[i]
}
mu.a_p_bl[1]
mu.a_p_bl[1,]
mu.a_p_bl[,1]
mu.a_p_bl <- matrix(numeric(0),nrow = 3000, ncol = 50)
# random effects of participant
for(i in levels(unique(df$participant))){
mu.a_p_bl[i] <- post$a + post$a_p[i]
}
mu.a_p_bl[,1]
mu.a_p_bl[1,]
rm(list = ls())

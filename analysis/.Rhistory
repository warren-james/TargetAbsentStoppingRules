}
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat$response = rt>0
}
View(simDat)
simDat>0
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
a <- 1
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
a<- 8
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a = 8 & simDat$response = FALSE]
simDat[simDat$a = 8 & simDat$response = FALSE,]
simDat[simDat$a == 8 & simDat$response == FALSE,]
simDat[simDat$a == 8 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == FALSE,]
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a == 8] <- TP
simDat[simDat$a == 1] <- TA
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
View(simDat)
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
simTrial <- function(p_up=b, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
b <- 0.2
} else {
a <- 1
b <- 0.5
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
system('g++ -v')
system('where make')
install.packages("rstan")
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 )
sample(1:2, 36)
sample(1:2, 36, replace = T)
sample(1:4, 32, replace = T)
sample(1:4, 32, replace = T)
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 4
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
w <- real_bathroom + real_kitchen + (real_bedroom/2)
w <- real_bathroom + real_kitchen + (real_bedroom/2)
k <- w
j <- real_bathroom + real_bedroom + real_kitchen
l <- j
total <- w+k+j+l
k_owe_j <- rent_person-j
k_owe_l <- rent_person-l
k_owe_w <- rent_person-w
k_rent <- k_owe_j + k_owe_l + k_owe_w
White_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (White_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
white_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (white_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
library(rethinking)
#### load in the data ####
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
setwd("F:/Uni/Github/TargetAbsentStoppingRules/analysis")
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
m_tp_diff_2 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a[participant]  + b_diff*theta + b_tp*targ_pr + b_tp_diff*targ_pr*theta,
# specify priors!
a ~ dnorm(1, 1),
#a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 1.5),
b_tp ~ dnorm(-1, 1),
b_tp_diff ~ dnorm(-1, 1),
sigma ~ dcauchy(0, 1),
#sig_p ~ dcauchy(0, 10)),
data = df)
)
m_tp_diff_2 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a[participant]  + b_diff*theta + b_tp*targ_pr + b_tp_diff*targ_pr*theta,
# specify priors!
a[participant] ~ dnorm(1, 1),
#a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 1.5),
b_tp ~ dnorm(-1, 1),
b_tp_diff ~ dnorm(-1, 1),
sigma ~ dcauchy(0, 1),
#sig_p ~ dcauchy(0, 10)),
data = df)
)
m_tp_diff_2 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a[participant]  + b_diff*theta + b_tp*targ_pr + b_tp_diff*targ_pr*theta,
# specify priors!
a[participant] ~ dnorm(1, 1),
#a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 1.5),
b_tp ~ dnorm(-1, 1),
b_tp_diff ~ dnorm(-1, 1),
sigma ~ dcauchy(0, 1),
#sig_p ~ dcauchy(0, 10)),
data = df)
)
m_tp_diff_4 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a[participant] + b_diff*theta + b_tp*targ_pr + b_tp_diff*targ_pr*theta,
# specify priors!
a[participant] ~ dnorm(1, 1),
b_diff ~ dnorm(1, 1.5),
b_tp ~ dnorm(-1, 1),
b_tp_diff ~ dnorm(-1, 1),
sigma ~ dcauchy(0, 1)),
data = df)
precis(m_tp_diff_4)
precis(m_tp_diff_4, depth=2)
setwd("F:/Uni/Github/TargetAbsentStoppingRules/analysis")
library(rethinking)
#### load in the data ####
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
m_tp_diff_3 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant] + b_diff*theta + b_tp*targ_pr + b_tp_diff*targ_pr*theta,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 1.5),
b_tp ~ dnorm(-1, 1),
b_tp_diff ~ dnorm(-1, 1),
sigma ~ dcauchy(0, 1),
sig_p ~ dcauchy(0, 10)),
data = df)
precis(m_tp_diff_3)
load("scratch/models/m_tp_diff_mixed_2")
precis(m_tp_diff_2)
save(m_tp_diff_3, file = "scratch/models/m_tp_diff_mixed_3")
setwd("E:/Github/TargetAbsentStoppingRules/analysis")
library(rethinking)
#### load in the data ####
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
df_TA <- df[df$targ_pr = 0]
df_TA <- df[df$targ_pr == 0]
df_TA <- df[df$targ_pr == 0,]
m_tp_diff_7 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant] + b_diff*theta_c,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 3)
sigma ~ dcauchy(0, 10),
sig_p ~ dcauchy(0, 10)),
data = df_TA)
m_tp_diff_7 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant] + b_diff*theta_c,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 3),
sigma ~ dcauchy(0, 10),
sig_p ~ dcauchy(0, 10)),
data = df_TA)
plot(m_tp_diff_7)
precis(m_tp_diff_7)
pairs(m_tp_diff_7)
pairs(m_tp_diff_7, pars = c("a", "b_diff", "sigma", "sig_p"), las = 1)
m_tp_diff_1 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant],
# specify priors!
a ~ dnorm(1, 1),
a_p[participant] ~ dnorm(0, sig_p),
sigma ~ dcauchy(0, 1),
sig_p ~ dcauchy(0, 1)),
data = df)
m_tp_diff_5 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p + b_diff*theta_c + b_tp*targ_pr + b_tp_diff*targ_pr*theta_c,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 3),
b_tp ~ dnorm(-1, 3),
b_tp_diff ~ dnorm(-1, 3),
sigma ~ dcauchy(0, 10),
sig_p ~ dcauchy(0, 10)),
data = df, control = list(adapt_delta = 0.99))
precis(m_tp_diff_5)
save(m_tp_diff_7, file = "scratch/models/m_tp_diff_mixed_7")
m_tp_diff_4 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant] + b_diff*theta_c + b_tp*targ_pr + b_tp_diff*targ_pr*theta_c,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 3),
b_tp ~ dnorm(-1, 3),
b_tp_diff ~ dnorm(-1, 3),
sigma ~ dcauchy(0, 10),
sig_p ~ dcauchy(0, 10)),
data = df)
#### save models into a subfolder within scratch ####
save(m_tp_diff_4, file = "scratch/models/m_tp_diff_mixed_4")
data(reedfrogs)
d <- reedfrogs
rm(list = ls())
data(reedfrogs)
d <- reedfrogs
rm(reedfrogs)
d$tank <- 1:nrow(d)
d$tank <- 1:nrow(d)
# fit model
m12.1 <- map2stan(
alist(
surv ~ dbinom( density, p),
logit(p) <- a_tank[tank],
a_tank[tank] ~ dnorm(0,5)
),
data = d)
precis(m12.1)
precis(m12.1, depth = 2)
m12.2 <- map2stan(
alist(
surv ~ dbinom(density, p),
logit(p) <- a_tank[tank],
a_tank[tank] <- dnorm(a,sigma),
a ~ dnorm(0,1),
sigma ~ dcauchy(0,1)
),
data = d, iter=4000, chains=4)
compare(m12.1,m12.2)
post <- extract.samples(m12.2)
# compute median intercept and account for logit()
d$propsurv.est <- logistic(apply(post$a_tank, 2, median))
library(rethinking)
#### load in the data ####
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
rm(list=ls())
library(rethinking)
#### load in the data ####
load("scratch/processed_data_nar.rda")
# make the tibble into a dataframe for map
df <- as.data.frame(df_correct_only)
# tidy
rm(df_correct_only)
m_tp_diff_8 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <- a + a_p[participant] + b_diff*theta_c + b_tp*targ_pr + b_tp_diff*targ_pr*theta_c,
# specify priors!
a ~ dnorm(1, 10),
a_p[participant] ~ dnorm(0, sig_p),
b_diff ~ dnorm(1, 3),
b_tp ~ dnorm(-1, 3),
b_tp_diff ~ dnorm(-1, 3),
sigma ~ dexp(1),
sig_p ~ dexp(1)),
data = df)
precis(m_tp_diff_8)
load("scratch/models/m_tp_diff_mixed_4")
precis(m_tp_diff_4)
save(m_tp_diff_8, file = "scratch/models/m_tp_diff_mixed_8")

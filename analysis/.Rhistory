}
simTrial()
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
sim <- simTrial()
simDat[i] <- cbind(a,rt=abs(sim))
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
#sim <- simTrial()
simDat[i] <- cbind(a,rt=abs(simTrial()))
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
simTrial()
simDat[i] <- cbind(a,rt)
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
simTrial()
simDat[i] <- data.frame(a,rt)
}
simDat <- replicate(1000, simTrial())
replicate(1, simTrial())
t <- replicate(1,simTrial())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(a,simTrial())
simDat[i] <- data.frame(a,rt)
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(a,simTrial())
simDat[i] <- cbind(a,rt)
}
rm(list = ls())
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(a,simTrial())
simDat[i] <- cbind(a,rt)
}
simDat <- data.frame("a", "rt"
)
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric())
View(simDat)
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(a,simTrial())
simDat[i] <- cbind(a,rt)
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i] <- cbind(a,rt)
}
rt <- replicate(1, simTrial())
rt
rt
rt
rt
rt
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i] <- cbind(a,rt=abs(rt))
}
rm(list = ls())
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- data.frame(a=numeric(), rt=numeric())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i] <- cbind(a,rt=abs(rt))
}
simDat <- data.frame(a=numeric(), rt=numeric())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i] <- cbind(a = a,rt=abs(rt))
}
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i] <- data.frame(a = a,rt=abs(rt))
}
View(simDat)
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
}
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat$response = rt>0
}
View(simDat)
simDat>0
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
a <- 1
p_down <- 0.33
# function(p_up=0.67, threshold=10, mu_quitTime=log(50), sigma_quitTime=.5)
# mu_quitTime = 7.822861
simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
a<- 8
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a = 8 & simDat$response = FALSE]
simDat[simDat$a = 8 & simDat$response = FALSE,]
simDat[simDat$a == 8 & simDat$response == FALSE,]
simDat[simDat$a == 8 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == FALSE,]
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a == 8] <- TP
simDat[simDat$a == 1] <- TA
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
View(simDat)
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
simTrial <- function(p_up=b, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
b <- 0.2
} else {
a <- 1
b <- 0.5
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
system('g++ -v')
system('where make')
install.packages("rstan")
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 )
sample(1:2, 36)
sample(1:2, 36, replace = T)
sample(1:4, 32, replace = T)
sample(1:4, 32, replace = T)
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 4
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
w <- real_bathroom + real_kitchen + (real_bedroom/2)
w <- real_bathroom + real_kitchen + (real_bedroom/2)
k <- w
j <- real_bathroom + real_bedroom + real_kitchen
l <- j
total <- w+k+j+l
k_owe_j <- rent_person-j
k_owe_l <- rent_person-l
k_owe_w <- rent_person-w
k_rent <- k_owe_j + k_owe_l + k_owe_w
White_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (White_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
white_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (white_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
setwd("E:/Github/TargetAbsentStoppingRules/analysis")
library(rethinking)
library(tidyverse)
library(scales)
library(ggthemes)
load("scratch/models/m_ta_only_temp_4")
# extract samples
post <- extract.samples(m_ta_only_temp_4)
mu.block <- post$a
mu.sine <- post$a + post$b_issi
mu.rand <- post$a + post$b_isra
mu.theta_bl <- post$b_theta
mu.theta_ra <- post$b_theta + post$b_ra_theta
mu.theta_si <- post$b_theta + post$b_si_theta

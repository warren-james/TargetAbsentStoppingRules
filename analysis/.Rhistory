simTrial <- function(p_up=0.2, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
# This if statement should switch between the up step being 10 or 1 depending on whether it's TA or TP
#TP <- runif(min=0, max=1, n=n)
#round(TP)
#walk[walk>p_down & TP>0.5]  <-  8
#walk[walk>p_down & TP<0.5]  <-  1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
a<- 8
simDat <- replicate(1000, simTrial())
df <- data.frame(rt=abs(simDat))
df$response = simDat>0
View(df)
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,1000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a = 8 & simDat$response = FALSE]
simDat[simDat$a = 8 & simDat$response = FALSE,]
simDat[simDat$a == 8 & simDat$response == FALSE,]
simDat[simDat$a == 8 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == TRUE,]
simDat[simDat$a == 1 & simDat$response == FALSE,]
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
View(simDat)
simDat[simDat$a == 8] <- TP
simDat[simDat$a == 1] <- TA
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat[simDat$a == 8] <- "TP"
simDat[simDat$a == 1] <- "TA"
View(simDat)
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
View(simDat)
simDat <- data.frame(a=numeric(), rt=numeric(), response=logical())
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
} else {
a <- 1
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
simTrial <- function(p_up=b, threshold=10, mu_quitTime=log(50), sigma_quitTime=.7)
{
p_down = 1-p_up
quitTime <- exp(rnorm(n=1, mean=mu_quitTime, sd=sigma_quitTime^2))
print(quitTime)
n <-quitTime
# for speed, pre-gen a load of random numbers
walk <-runif(min=0, max=1, n=n)
# generate a random walk for the n samples
walk[walk<=p_down] <- -1
walk[walk>p_down] <- a
walk <- cumsum(walk)
respondTP = max(walk)>threshold
if (respondTP) {
rt <- min(which(walk>threshold))
} else {
rt = -quitTime
}
return(rt)
}
for(i in seq(1,2000)) {
temp <- runif(max=1, min=0, n=1)
if(temp >0.5) {
a <- 8
b <- 0.2
} else {
a <- 1
b <- 0.5
}
rt <- replicate(1,simTrial())
simDat[i,1] <- a
simDat[i,2] <- abs(rt)
simDat[i,3] = rt>0
}
simDat$a[simDat$a == 8] <- "TP"
simDat$a[simDat$a == 1] <- "TA"
plt <- ggplot(simDat, aes(x=rt, fill=response)) + geom_density(alpha=0.5) + facet_wrap(~a)
plt
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
system('g++ -v')
system('where make')
install.packages("rstan")
fx <- inline::cxxfunction( signature(x = "integer", y = "numeric" ) , '
return ScalarReal( INTEGER(x)[0] * REAL(y)[0] ) ;
' )
fx( 2L, 5 )
sample(1:2, 36)
sample(1:2, 36, replace = T)
sample(1:4, 32, replace = T)
sample(1:4, 32, replace = T)
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 3
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
flat_total <- 1200
rent_person <- 400
total_rooms <- 3
total_people <- 4
bedroom <- rent_person/total_rooms
bathroom <- rent_person/total_rooms
kitchen <- rent_person/total_rooms
real_bedroom <- bedroom
real_bathroom <- rent_person/total_people
real_kitchen <- rent_person/total_people
w <- real_bathroom + real_kitchen + (real_bedroom/2)
w <- real_bathroom + real_kitchen + (real_bedroom/2)
k <- w
j <- real_bathroom + real_bedroom + real_kitchen
l <- j
total <- w+k+j+l
k_owe_j <- rent_person-j
k_owe_l <- rent_person-l
k_owe_w <- rent_person-w
k_rent <- k_owe_j + k_owe_l + k_owe_w
White_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (White_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
white_pop <- 0.72
black_pop <- 0.26
white_vote_M <- 0.67
black_vote_M <- 0.04
white_vote_J <- 0.31
black_vote_J <- 0.96
M_votes <- (white_pop*white_vote_M)+(black_pop*black_vote_M)
J_votes <- (white_pop*white_vote_J)+(black_pop*black_vote_J)
setwd("E:/Github/TargetAbsentStoppingRules/analysis")
library(rethinking)
rstan_options(auto_write = TRUE)
#### TA judgement model ####
# load in data
load("scratch/processed_data_nar_TA.rda")
# turn tibble into data.frame for map
df <- as.data.frame(df_TA)
# tidy
rm(df_TA)
df$block_type_id <- coerce_index(df$block_type)
# run model
m_ta_only_temp_2 <- map2stan(
alist(
rt ~ dlnorm(mu, sigma),
mu <-  A + B_theta,
A <- a + a_p[participant] + a_bt[block_type_id],
B_theta <- (b_theta + b_theta_p[participant]) * theta,
# adaptive priors
c(a_p, b_theta_p)[participant] ~ dmvnormNC(sigma_p, Rho_p),
a_bt[block_type_id] ~ dnorm(0, sigma_bt),
# fixed priors
a ~ dnorm(1, 2),
b_theta ~ dnorm(1,3),
sigma ~ dcauchy(0, 1.5),
sigma_p ~ dcauchy(0, 1.5),
sigma_bt ~ dcauchy(0,1.5),
Rho_p ~ dlkjcorr(4)
),
data = df,
iter = 2000, warmup = 1000, chains = 3, cores = 3)
save(m_ta_only_temp_2, file = "scratch/models/m_ta_only_temp_2")
precis(m_ta_only_temp_2, depth = 2)
#### For model with varying intercepts of block type ####
levels(df$block_type_id)
str(df)
rm(list = ls())
library(tidyverse)
load("scratch/processed_data.rda")
knitr::opts_chunk$set(fig.width=12, fig.height=6.5)
df$difficulty <- round(df$difficulty, digits = 1)
df$TATP <- 0
# Say when it's TA and when it's TP
df$TATP[df$key == "l"] <- "TP"
df$TATP[df$key == "r"] <- "TA"
toberemoved <- which(df$site == "Essex" & df$group == "SIBL")
df <- df[-toberemoved,]
rm(toberemoved)
total_observations <- length(df$rt)
# get average number of trials
temp <- group_by(df, participant,block_type,block,group)
number_of_trials <- summarise(temp, num_trials = length(rt))
rm(temp)
total_observations
trials_per_participant = mean(number_of_trials$num_trials)
trials_per_participant
df <- df[complete.cases(df),]
total_observations_nar <- length(df$rt)
temp <- group_by(df, participant,block_type,block,group)
number_of_trials <- summarise(temp, num_trials = length(rt))
rm(temp)
trials_per_participant_nar <- mean(number_of_trials$num_trials)
percent_remaining <- round((total_observations_nar/total_observations)*100)
total_observations_nar
trials_per_participant_nar
trials_per_block_plt = ggplot(number_of_trials, aes(num_trials))
trials_per_block_plt = trials_per_block_plt + geom_bar()
trials_per_block_plt = trials_per_block_plt + xlab("Number of trials")
trials_per_block_plt = trials_per_block_plt + ylab("No. participants")
temp <- group_by(df, participant,block_type,group)
number_of_trials_2 <- summarise(temp, num_trials = length(rt))
rm(temp)
trials_total_plt = ggplot(number_of_trials_2, aes(num_trials))
trials_total_plt = trials_total_plt + geom_bar()
trials_total_plt = trials_total_plt + xlab("Number of trials")
trials_total_plt = trials_total_plt + ylab("No. participants")
trials_per_block_plt
trials_total_plt
# so mean and median rt by group, block type, difficulty, and Ta vs Tp
temp = group_by(df, group, block_type, difficulty, targ_pr)
desc_stats = summarise(temp, mean_rt = mean(rt),
median_rt = median(rt),
sdev = sd(rt),
N = length(rt),
se = sdev/sqrt(N),
upper_mean = mean_rt + se,
lower_mean = mean_rt - se,
upper_median = median_rt + se,
lower_median = median_rt - se)
rm(temp)
mean_rt_plot = ggplot(desc_stats, aes(difficulty, mean_rt, colour = block_type))
mean_rt_plot = mean_rt_plot + geom_point()
mean_rt_plot = mean_rt_plot + geom_errorbar(aes(ymin = lower_mean, ymax = upper_mean))
mean_rt_plot = mean_rt_plot + facet_grid(group~targ_pr)
median_rt_plot = ggplot(desc_stats, aes(difficulty, median_rt, colour = block_type))
median_rt_plot = median_rt_plot + geom_point()
median_rt_plot = median_rt_plot + geom_errorbar(aes(ymin = lower_median, ymax = upper_median))
median_rt_plot = median_rt_plot + facet_grid(group~targ_pr)
mean_rt_plot
median_rt_plot
temp = group_by(df, group, block_type, difficulty, targ_pr)
desc_stats_acc = summarise(temp, mean_correct = mean(correct),
median_correct = median(correct),
sdev = sd(correct),
N = length(correct),
se = sdev/sqrt(N),
upper_mean = mean_correct + se,
lower_mean = mean_correct - se,
upper_median = median_correct + se,
lower_median = median_correct - se)
rm(temp)
mean_acc_plot = ggplot(desc_stats_acc, aes(difficulty, mean_correct, colour = block_type))
mean_acc_plot = mean_acc_plot + geom_point()
mean_acc_plot = mean_acc_plot + geom_errorbar(aes(ymin = lower_mean, ymax = upper_mean))
mean_acc_plot = mean_acc_plot + facet_grid(group~targ_pr)
mean_acc_plot
# make separate density plot data frame
dense_data <- df
# make targ_pr a factor
dense_data$targ_pr <- as.factor(dense_data$targ_pr)
# make difficulty a factor just for this
dense_data$difficulty <- as.factor(dense_data$difficulty)
density_plot_RABL = ggplot(dense_data[dense_data$group == "RABL",], aes(rt, colour = targ_pr))
density_plot_RABL = density_plot_RABL + geom_density(alpha = 0.1)
density_plot_RABL = density_plot_RABL + facet_wrap(~block_type)
density_plot_RABL = density_plot_RABL + ggtitle("RABL group")
density_plot_SIBL = ggplot(dense_data[dense_data$group == "SIBL",], aes(rt, colour = targ_pr))
density_plot_SIBL = density_plot_SIBL + geom_density(alpha = 0.1)
density_plot_SIBL = density_plot_SIBL + facet_wrap(~block_type)
density_plot_SIBL = density_plot_SIBL + ggtitle("SIBL group")
density_plot_RABL
density_plot_SIBL
density_plot_RABL_diff = ggplot(dense_data[dense_data$group == "RABL",], aes(rt, colour = difficulty))
density_plot_RABL_diff = density_plot_RABL_diff + geom_density(alpha = 0.1)
density_plot_RABL_diff = density_plot_RABL_diff + facet_grid(targ_pr~block_type)
density_plot_RABL_diff = density_plot_RABL_diff + ggtitle("RABL group")
density_plot_SIBL_diff = ggplot(dense_data[dense_data$group == "SIBL",], aes(rt, colour = difficulty))
density_plot_SIBL_diff = density_plot_SIBL_diff + geom_density(alpha = 0.1)
density_plot_SIBL_diff = density_plot_SIBL_diff + facet_grid(targ_pr~block_type)
density_plot_SIBL_diff = density_plot_SIBL_diff + ggtitle("SIBL group")
density_plot_RABL_diff
density_plot_SIBL_diff
# centre p_rt
df$c_p_rt <- df$p_rt - mean(df$p_rt)
# change difficulty name
#colnames(df)[7] <- "theta"
#rescale difficulty for the models
df$theta <- round(df$difficulty/pi, digits = 3)
# create a centred version
df$theta_c <- df$theta - mean(df$theta)
df$isra <- ifelse(df$block_type == "random", 1,0)
df$issi <- ifelse(df$block_type == "sinewave",1,0)
df$participant <- as.factor(df$participant)
df$participant <- as.numeric(df$participant)
df_correct_only <- df[df$correct == 1,]
# remove everything but the df
rm(list=ls()[!(ls() %in% c("df","df_correct_only"))])
# Save only the new data frame
save(df, df_correct_only, file = "scratch/processed_data_nar.rda")
df$block_type_id <- coerce_index(df$block_type)
# subset the data
df_TA <- df[df$TATP == "TA",]
#tidy up
rm(df, df_correct_only)
# save this
save(df_TA, file = "scratch/processed_data_nar_TA.rda")
dir("scratch/models/")
load("scratch/models/m_ta_only_temp_2")
precis(m_ta_only_temp_2)
post <- extract.samples(m_ta_only_2)
post <- extract.samples(m_ta_only_temp_2)
df <- df_TA
df$block_type_id <- as.factor(df$block_type_id)
head(df)
View(df)
get_hpdi_region_from_samples <- function(m, post, ln = TRUE) {
pred_data <- list(
participant = rep(1:length(unique(df$participant)), each = 4),
theta =   rep(c(0.12, 0.88, 0.12, 0.88), length(unique(df$participant))),
block_type = rep(c(1,1,1,1,2,2,2,2,3,3,3,3), length(unique(df$participant))))#,
#targ_pr = rep(c(0, 0, 1, 1), length(unique(df$participant))))
mu <- link(m, data = pred_data)
mu.PI <- apply(mu, 2, PI)
pred_data$lower <- mu.PI[1,]
pred_data$upper <- mu.PI[2,]
pred_data$block_type <- as.factor(pred_data$block_type)
levels(pred_data$block_type) <- c("blocked", "random", "sinewave")
if (ln == TRUE) {
pred_data$lower <- exp(pred_data$lower)
pred_data$upper <- exp(pred_data$upper)
}
names(pred_data)[1] <- "participant"
pred_data <- as.data.frame(pred_data)
return(pred_data)
}
sequence <- c(1,10,11,12,13,14,15,16,17,18,19,2,20,21,22,23,24,25,26,27,
28,29,3,30,31,32,33,34,35,36,37,38,39,4,40,41,42,43,44,45,
46,47,48,49,5,50,6,7,8,9)
model_lines <- get_hpdi_region_from_samples(m_ta_only_temp_2, post, TRUE)
rep(c(1,1,1,1,2,2,2,2,3,3,3,3), length(unique(df$participant)))
rep(c(0.12, 0.88, 0.12, 0.88), length(unique(df$participant)))
get_hpdi_region_from_samples <- function(m, post, ln = TRUE) {
pred_data <- list(
participant = rep(1:length(unique(df$participant)), each = 4),
theta =   rep(c(0.12, 0.88, 0.12, 0.88), length(unique(df$participant))),
block_type = rep(c(1,1,1,1,2,2,2,2,3,3,3,3), length(unique(df$participant))))#,
#targ_pr = rep(c(0, 0, 1, 1), length(unique(df$participant))))
mu <- link(m, data = pred_data)
mu.PI <- apply(mu, 2, PI)
pred_data$lower <- mu.PI[1,]
pred_data$upper <- mu.PI[2,]
pred_data$block_type_id <- as.factor(pred_data$block_type_id)
levels(pred_data$block_type_id) <- c("blocked", "random", "sinewave")
if (ln == TRUE) {
pred_data$lower <- exp(pred_data$lower)
pred_data$upper <- exp(pred_data$upper)
}
names(pred_data)[1] <- "participant"
pred_data <- as.data.frame(pred_data)
return(pred_data)
}
model_lines <- get_hpdi_region_from_samples(m_ta_only_temp_2, post, TRUE)
View(df)
get_hpdi_region_from_samples <- function(m, post, ln = TRUE) {
pred_data <- list(
participant = rep(1:length(unique(df$participant)), each = 4),
theta =   rep(c(0.12, 0.88, 0.12, 0.88), length(unique(df$participant))),
block_type_id = rep(c(1,1,1,1,2,2,2,2,3,3,3,3), length(unique(df$participant))))#,
#targ_pr = rep(c(0, 0, 1, 1), length(unique(df$participant))))
mu <- link(m, data = pred_data)
mu.PI <- apply(mu, 2, PI)
pred_data$lower <- mu.PI[1,]
pred_data$upper <- mu.PI[2,]
pred_data$block_type_id <- as.factor(pred_data$block_type_id)
levels(pred_data$block_type_id) <- c("blocked", "random", "sinewave")
if (ln == TRUE) {
pred_data$lower <- exp(pred_data$lower)
pred_data$upper <- exp(pred_data$upper)
}
names(pred_data)[1] <- "participant"
pred_data <- as.data.frame(pred_data)
return(pred_data)
}
model_lines <- get_hpdi_region_from_samples(m_ta_only_temp_2, post, TRUE)
get_hpdi_region_from_samples <- function(m, post, ln = TRUE) {
pred_data <- list(
participant = rep(1:length(unique(df$participant)), each = 4),
theta =   rep(c(0.12, 0.88, 0.12, 0.88), length(unique(df$participant))),
block_type_id = rep(c(1,1,2,2,3,3), length(unique(df$participant))))#,
#targ_pr = rep(c(0, 0, 1, 1), length(unique(df$participant))))
mu <- link(m, data = pred_data)
mu.PI <- apply(mu, 2, PI)
pred_data$lower <- mu.PI[1,]
pred_data$upper <- mu.PI[2,]
pred_data$block_type_id <- as.factor(pred_data$block_type_id)
levels(pred_data$block_type_id) <- c("blocked", "random", "sinewave")
if (ln == TRUE) {
pred_data$lower <- exp(pred_data$lower)
pred_data$upper <- exp(pred_data$upper)
}
names(pred_data)[1] <- "participant"
pred_data <- as.data.frame(pred_data)
return(pred_data)
}
model_lines <- get_hpdi_region_from_samples(m_ta_only_temp_2, post, TRUE)
get_hpdi_region_from_samples <- function(m, post, ln = TRUE) {
pred_data <- list(
participant = rep(1:length(unique(df$participant)), each = 4),
theta =   rep(c(0.12, 0.88, 0.12, 0.88, 0.12, 0.88), length(unique(df$participant))),
block_type_id = rep(c(1,1,2,2,3,3), length(unique(df$participant))))#,
#targ_pr = rep(c(0, 0, 1, 1), length(unique(df$participant))))
mu <- link(m, data = pred_data)
mu.PI <- apply(mu, 2, PI)
pred_data$lower <- mu.PI[1,]
pred_data$upper <- mu.PI[2,]
pred_data$block_type_id <- as.factor(pred_data$block_type_id)
levels(pred_data$block_type_id) <- c("blocked", "random", "sinewave")
if (ln == TRUE) {
pred_data$lower <- exp(pred_data$lower)
pred_data$upper <- exp(pred_data$upper)
}
names(pred_data)[1] <- "participant"
pred_data <- as.data.frame(pred_data)
return(pred_data)
}
model_lines <- get_hpdi_region_from_samples(m_ta_only_temp_2, post, TRUE)
